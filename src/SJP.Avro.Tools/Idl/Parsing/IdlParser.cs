//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from Idl.g4 by ANTLR 4.13.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.2")]
public partial class IdlParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		T__0=1, DocComment=2, EmptyComment=3, MultiLineComment=4, SingleLineComment=5, 
		WS=6, Protocol=7, Namespace=8, Import=9, IDL=10, Schema=11, Enum=12, Fixed=13, 
		Error=14, Record=15, Array=16, Map=17, Union=18, Boolean=19, Int=20, Long=21, 
		Float=22, Double=23, String=24, Bytes=25, Null=26, BTrue=27, BFalse=28, 
		Decimal=29, Date=30, Time=31, Timestamp=32, LocalTimestamp=33, UUID=34, 
		Void=35, Oneway=36, Throws=37, LParen=38, RParen=39, LBrace=40, RBrace=41, 
		LBracket=42, RBracket=43, Colon=44, Semicolon=45, Comma=46, At=47, EqualsOp=48, 
		Dot=49, Dash=50, QuestionMark=51, LT=52, GT=53, StringLiteral=54, IntegerLiteral=55, 
		FloatingPointLiteral=56, IdentifierToken=57;
	public const int
		RULE_idlFile = 0, RULE_protocolDeclaration = 1, RULE_protocolDeclarationBody = 2, 
		RULE_namespaceDeclaration = 3, RULE_mainSchemaDeclaration = 4, RULE_identifier = 5, 
		RULE_schemaProperty = 6, RULE_importStatement = 7, RULE_namedSchemaDeclaration = 8, 
		RULE_fixedDeclaration = 9, RULE_enumDeclaration = 10, RULE_enumSymbol = 11, 
		RULE_enumDefault = 12, RULE_recordDeclaration = 13, RULE_recordBody = 14, 
		RULE_fieldDeclaration = 15, RULE_variableDeclaration = 16, RULE_messageDeclaration = 17, 
		RULE_formalParameter = 18, RULE_resultType = 19, RULE_fullType = 20, RULE_plainType = 21, 
		RULE_nullableType = 22, RULE_primitiveType = 23, RULE_arrayType = 24, 
		RULE_mapType = 25, RULE_unionType = 26, RULE_jsonValue = 27, RULE_jsonLiteral = 28, 
		RULE_jsonObject = 29, RULE_jsonPair = 30, RULE_jsonArray = 31;
	public static readonly string[] ruleNames = {
		"idlFile", "protocolDeclaration", "protocolDeclarationBody", "namespaceDeclaration", 
		"mainSchemaDeclaration", "identifier", "schemaProperty", "importStatement", 
		"namedSchemaDeclaration", "fixedDeclaration", "enumDeclaration", "enumSymbol", 
		"enumDefault", "recordDeclaration", "recordBody", "fieldDeclaration", 
		"variableDeclaration", "messageDeclaration", "formalParameter", "resultType", 
		"fullType", "plainType", "nullableType", "primitiveType", "arrayType", 
		"mapType", "unionType", "jsonValue", "jsonLiteral", "jsonObject", "jsonPair", 
		"jsonArray"
	};

	private static readonly string[] _LiteralNames = {
		null, "'\\u001A'", null, "'/**/'", null, null, null, "'protocol'", "'namespace'", 
		"'import'", "'idl'", "'schema'", "'enum'", "'fixed'", "'error'", "'record'", 
		"'array'", "'map'", "'union'", "'boolean'", "'int'", "'long'", "'float'", 
		"'double'", "'string'", "'bytes'", "'null'", "'true'", "'false'", "'decimal'", 
		"'date'", "'time_ms'", "'timestamp_ms'", "'local_timestamp_ms'", "'uuid'", 
		"'void'", "'oneway'", "'throws'", "'('", "')'", "'{'", "'}'", "'['", "']'", 
		"':'", "';'", "','", "'@'", "'='", "'.'", "'-'", "'?'", "'<'", "'>'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, "DocComment", "EmptyComment", "MultiLineComment", "SingleLineComment", 
		"WS", "Protocol", "Namespace", "Import", "IDL", "Schema", "Enum", "Fixed", 
		"Error", "Record", "Array", "Map", "Union", "Boolean", "Int", "Long", 
		"Float", "Double", "String", "Bytes", "Null", "BTrue", "BFalse", "Decimal", 
		"Date", "Time", "Timestamp", "LocalTimestamp", "UUID", "Void", "Oneway", 
		"Throws", "LParen", "RParen", "LBrace", "RBrace", "LBracket", "RBracket", 
		"Colon", "Semicolon", "Comma", "At", "Equals", "Dot", "Dash", "QuestionMark", 
		"LT", "GT", "StringLiteral", "IntegerLiteral", "FloatingPointLiteral", 
		"IdentifierToken"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Idl.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static IdlParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public IdlParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public IdlParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class IdlFileContext : ParserRuleContext {
		public ProtocolDeclarationContext protocol;
		public NamespaceDeclarationContext @namespace;
		public MainSchemaDeclarationContext mainSchema;
		public ImportStatementContext _importStatement;
		public IList<ImportStatementContext> _imports = new List<ImportStatementContext>();
		public NamedSchemaDeclarationContext _namedSchemaDeclaration;
		public IList<NamedSchemaDeclarationContext> _namedSchemas = new List<NamedSchemaDeclarationContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(IdlParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ProtocolDeclarationContext protocolDeclaration() {
			return GetRuleContext<ProtocolDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NamespaceDeclarationContext namespaceDeclaration() {
			return GetRuleContext<NamespaceDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MainSchemaDeclarationContext mainSchemaDeclaration() {
			return GetRuleContext<MainSchemaDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImportStatementContext[] importStatement() {
			return GetRuleContexts<ImportStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImportStatementContext importStatement(int i) {
			return GetRuleContext<ImportStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NamedSchemaDeclarationContext[] namedSchemaDeclaration() {
			return GetRuleContexts<NamedSchemaDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NamedSchemaDeclarationContext namedSchemaDeclaration(int i) {
			return GetRuleContext<NamedSchemaDeclarationContext>(i);
		}
		public IdlFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_idlFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterIdlFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitIdlFile(this);
		}
	}

	[RuleVersion(0)]
	public IdlFileContext idlFile() {
		IdlFileContext _localctx = new IdlFileContext(Context, State);
		EnterRule(_localctx, 0, RULE_idlFile);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 78;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 64;
				_localctx.protocol = protocolDeclaration();
				}
				break;
			case 2:
				{
				State = 66;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Namespace) {
					{
					State = 65;
					_localctx.@namespace = namespaceDeclaration();
					}
				}

				State = 69;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Schema) {
					{
					State = 68;
					_localctx.mainSchema = mainSchemaDeclaration();
					}
				}

				State = 75;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 140737488417284L) != 0)) {
					{
					State = 73;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case Import:
						{
						State = 71;
						_localctx._importStatement = importStatement();
						_localctx._imports.Add(_localctx._importStatement);
						}
						break;
					case DocComment:
					case Enum:
					case Fixed:
					case Error:
					case Record:
					case At:
						{
						State = 72;
						_localctx._namedSchemaDeclaration = namedSchemaDeclaration();
						_localctx._namedSchemas.Add(_localctx._namedSchemaDeclaration);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 77;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			State = 87;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==T__0) {
				{
				State = 80;
				Match(T__0);
				State = 84;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
				while ( _alt!=1 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1+1 ) {
						{
						{
						State = 81;
						MatchWildcard();
						}
						} 
					}
					State = 86;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
				}
				}
			}

			State = 89;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProtocolDeclarationContext : ParserRuleContext {
		public IToken doc;
		public SchemaPropertyContext _schemaProperty;
		public IList<SchemaPropertyContext> _schemaProperties = new List<SchemaPropertyContext>();
		public IdentifierContext name;
		public ProtocolDeclarationBodyContext body;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Protocol() { return GetToken(IdlParser.Protocol, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProtocolDeclarationBodyContext protocolDeclarationBody() {
			return GetRuleContext<ProtocolDeclarationBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocComment() { return GetToken(IdlParser.DocComment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext[] schemaProperty() {
			return GetRuleContexts<SchemaPropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext schemaProperty(int i) {
			return GetRuleContext<SchemaPropertyContext>(i);
		}
		public ProtocolDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_protocolDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterProtocolDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitProtocolDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ProtocolDeclarationContext protocolDeclaration() {
		ProtocolDeclarationContext _localctx = new ProtocolDeclarationContext(Context, State);
		EnterRule(_localctx, 2, RULE_protocolDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 92;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocComment) {
				{
				State = 91;
				_localctx.doc = Match(DocComment);
				}
			}

			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==At) {
				{
				{
				State = 94;
				_localctx._schemaProperty = schemaProperty();
				_localctx._schemaProperties.Add(_localctx._schemaProperty);
				}
				}
				State = 99;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 100;
			Match(Protocol);
			State = 101;
			_localctx.name = identifier();
			State = 102;
			_localctx.body = protocolDeclarationBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProtocolDeclarationBodyContext : ParserRuleContext {
		public ImportStatementContext _importStatement;
		public IList<ImportStatementContext> _imports = new List<ImportStatementContext>();
		public NamedSchemaDeclarationContext _namedSchemaDeclaration;
		public IList<NamedSchemaDeclarationContext> _namedSchemas = new List<NamedSchemaDeclarationContext>();
		public MessageDeclarationContext _messageDeclaration;
		public IList<MessageDeclarationContext> _messages = new List<MessageDeclarationContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBrace() { return GetToken(IdlParser.LBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBrace() { return GetToken(IdlParser.RBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ImportStatementContext[] importStatement() {
			return GetRuleContexts<ImportStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImportStatementContext importStatement(int i) {
			return GetRuleContext<ImportStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NamedSchemaDeclarationContext[] namedSchemaDeclaration() {
			return GetRuleContexts<NamedSchemaDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NamedSchemaDeclarationContext namedSchemaDeclaration(int i) {
			return GetRuleContext<NamedSchemaDeclarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MessageDeclarationContext[] messageDeclaration() {
			return GetRuleContexts<MessageDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MessageDeclarationContext messageDeclaration(int i) {
			return GetRuleContext<MessageDeclarationContext>(i);
		}
		public ProtocolDeclarationBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_protocolDeclarationBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterProtocolDeclarationBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitProtocolDeclarationBody(this);
		}
	}

	[RuleVersion(0)]
	public ProtocolDeclarationBodyContext protocolDeclarationBody() {
		ProtocolDeclarationBodyContext _localctx = new ProtocolDeclarationBodyContext(Context, State);
		EnterRule(_localctx, 4, RULE_protocolDeclarationBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 104;
			Match(LBrace);
			State = 110;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 144256200442118020L) != 0)) {
				{
				State = 108;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
				case 1:
					{
					State = 105;
					_localctx._importStatement = importStatement();
					_localctx._imports.Add(_localctx._importStatement);
					}
					break;
				case 2:
					{
					State = 106;
					_localctx._namedSchemaDeclaration = namedSchemaDeclaration();
					_localctx._namedSchemas.Add(_localctx._namedSchemaDeclaration);
					}
					break;
				case 3:
					{
					State = 107;
					_localctx._messageDeclaration = messageDeclaration();
					_localctx._messages.Add(_localctx._messageDeclaration);
					}
					break;
				}
				}
				State = 112;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 113;
			Match(RBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamespaceDeclarationContext : ParserRuleContext {
		public IdentifierContext @namespace;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Namespace() { return GetToken(IdlParser.Namespace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(IdlParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public NamespaceDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namespaceDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterNamespaceDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitNamespaceDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public NamespaceDeclarationContext namespaceDeclaration() {
		NamespaceDeclarationContext _localctx = new NamespaceDeclarationContext(Context, State);
		EnterRule(_localctx, 6, RULE_namespaceDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 115;
			Match(Namespace);
			State = 116;
			_localctx.@namespace = identifier();
			State = 117;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MainSchemaDeclarationContext : ParserRuleContext {
		public FullTypeContext mainSchema;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Schema() { return GetToken(IdlParser.Schema, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(IdlParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullTypeContext fullType() {
			return GetRuleContext<FullTypeContext>(0);
		}
		public MainSchemaDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mainSchemaDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterMainSchemaDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitMainSchemaDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public MainSchemaDeclarationContext mainSchemaDeclaration() {
		MainSchemaDeclarationContext _localctx = new MainSchemaDeclarationContext(Context, State);
		EnterRule(_localctx, 8, RULE_mainSchemaDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			Match(Schema);
			State = 120;
			_localctx.mainSchema = fullType();
			State = 121;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public IToken word;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IdentifierToken() { return GetToken(IdlParser.IdentifierToken, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Protocol() { return GetToken(IdlParser.Protocol, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Namespace() { return GetToken(IdlParser.Namespace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Import() { return GetToken(IdlParser.Import, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDL() { return GetToken(IdlParser.IDL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Schema() { return GetToken(IdlParser.Schema, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Enum() { return GetToken(IdlParser.Enum, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Fixed() { return GetToken(IdlParser.Fixed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Error() { return GetToken(IdlParser.Error, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Record() { return GetToken(IdlParser.Record, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Array() { return GetToken(IdlParser.Array, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Map() { return GetToken(IdlParser.Map, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Union() { return GetToken(IdlParser.Union, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Boolean() { return GetToken(IdlParser.Boolean, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Int() { return GetToken(IdlParser.Int, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Long() { return GetToken(IdlParser.Long, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Float() { return GetToken(IdlParser.Float, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Double() { return GetToken(IdlParser.Double, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(IdlParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Bytes() { return GetToken(IdlParser.Bytes, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Null() { return GetToken(IdlParser.Null, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BTrue() { return GetToken(IdlParser.BTrue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BFalse() { return GetToken(IdlParser.BFalse, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Decimal() { return GetToken(IdlParser.Decimal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Date() { return GetToken(IdlParser.Date, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Time() { return GetToken(IdlParser.Time, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Timestamp() { return GetToken(IdlParser.Timestamp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LocalTimestamp() { return GetToken(IdlParser.LocalTimestamp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UUID() { return GetToken(IdlParser.UUID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Void() { return GetToken(IdlParser.Void, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Oneway() { return GetToken(IdlParser.Oneway, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Throws() { return GetToken(IdlParser.Throws, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 10, RULE_identifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 123;
			_localctx.word = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 144115462953762688L) != 0)) ) {
				_localctx.word = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SchemaPropertyContext : ParserRuleContext {
		public IdentifierContext name;
		public JsonValueContext value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode At() { return GetToken(IdlParser.At, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LParen() { return GetToken(IdlParser.LParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RParen() { return GetToken(IdlParser.RParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueContext jsonValue() {
			return GetRuleContext<JsonValueContext>(0);
		}
		public SchemaPropertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_schemaProperty; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterSchemaProperty(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitSchemaProperty(this);
		}
	}

	[RuleVersion(0)]
	public SchemaPropertyContext schemaProperty() {
		SchemaPropertyContext _localctx = new SchemaPropertyContext(Context, State);
		EnterRule(_localctx, 12, RULE_schemaProperty);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 125;
			Match(At);
			State = 126;
			_localctx.name = identifier();
			State = 127;
			Match(LParen);
			State = 128;
			_localctx.value = jsonValue();
			State = 129;
			Match(RParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImportStatementContext : ParserRuleContext {
		public IToken importType;
		public IToken location;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Import() { return GetToken(IdlParser.Import, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(IdlParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(IdlParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Schema() { return GetToken(IdlParser.Schema, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Protocol() { return GetToken(IdlParser.Protocol, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDL() { return GetToken(IdlParser.IDL, 0); }
		public ImportStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_importStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterImportStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitImportStatement(this);
		}
	}

	[RuleVersion(0)]
	public ImportStatementContext importStatement() {
		ImportStatementContext _localctx = new ImportStatementContext(Context, State);
		EnterRule(_localctx, 14, RULE_importStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 131;
			Match(Import);
			State = 132;
			_localctx.importType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 3200L) != 0)) ) {
				_localctx.importType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 133;
			_localctx.location = Match(StringLiteral);
			State = 134;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedSchemaDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FixedDeclarationContext fixedDeclaration() {
			return GetRuleContext<FixedDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumDeclarationContext enumDeclaration() {
			return GetRuleContext<EnumDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordDeclarationContext recordDeclaration() {
			return GetRuleContext<RecordDeclarationContext>(0);
		}
		public NamedSchemaDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedSchemaDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterNamedSchemaDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitNamedSchemaDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public NamedSchemaDeclarationContext namedSchemaDeclaration() {
		NamedSchemaDeclarationContext _localctx = new NamedSchemaDeclarationContext(Context, State);
		EnterRule(_localctx, 16, RULE_namedSchemaDeclaration);
		try {
			State = 139;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 136;
				fixedDeclaration();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 137;
				enumDeclaration();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 138;
				recordDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FixedDeclarationContext : ParserRuleContext {
		public IToken doc;
		public SchemaPropertyContext _schemaProperty;
		public IList<SchemaPropertyContext> _schemaProperties = new List<SchemaPropertyContext>();
		public IdentifierContext name;
		public IToken size;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Fixed() { return GetToken(IdlParser.Fixed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LParen() { return GetToken(IdlParser.LParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RParen() { return GetToken(IdlParser.RParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(IdlParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntegerLiteral() { return GetToken(IdlParser.IntegerLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocComment() { return GetToken(IdlParser.DocComment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext[] schemaProperty() {
			return GetRuleContexts<SchemaPropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext schemaProperty(int i) {
			return GetRuleContext<SchemaPropertyContext>(i);
		}
		public FixedDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fixedDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterFixedDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitFixedDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public FixedDeclarationContext fixedDeclaration() {
		FixedDeclarationContext _localctx = new FixedDeclarationContext(Context, State);
		EnterRule(_localctx, 18, RULE_fixedDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 142;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocComment) {
				{
				State = 141;
				_localctx.doc = Match(DocComment);
				}
			}

			State = 147;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==At) {
				{
				{
				State = 144;
				_localctx._schemaProperty = schemaProperty();
				_localctx._schemaProperties.Add(_localctx._schemaProperty);
				}
				}
				State = 149;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 150;
			Match(Fixed);
			State = 151;
			_localctx.name = identifier();
			State = 152;
			Match(LParen);
			State = 153;
			_localctx.size = Match(IntegerLiteral);
			State = 154;
			Match(RParen);
			State = 155;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumDeclarationContext : ParserRuleContext {
		public IToken doc;
		public SchemaPropertyContext _schemaProperty;
		public IList<SchemaPropertyContext> _schemaProperties = new List<SchemaPropertyContext>();
		public IdentifierContext name;
		public EnumSymbolContext _enumSymbol;
		public IList<EnumSymbolContext> _enumSymbols = new List<EnumSymbolContext>();
		public EnumDefaultContext defaultSymbol;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Enum() { return GetToken(IdlParser.Enum, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBrace() { return GetToken(IdlParser.LBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBrace() { return GetToken(IdlParser.RBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocComment() { return GetToken(IdlParser.DocComment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext[] schemaProperty() {
			return GetRuleContexts<SchemaPropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext schemaProperty(int i) {
			return GetRuleContext<SchemaPropertyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumSymbolContext[] enumSymbol() {
			return GetRuleContexts<EnumSymbolContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumSymbolContext enumSymbol(int i) {
			return GetRuleContext<EnumSymbolContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumDefaultContext enumDefault() {
			return GetRuleContext<EnumDefaultContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(IdlParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(IdlParser.Comma, i);
		}
		public EnumDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterEnumDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitEnumDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public EnumDeclarationContext enumDeclaration() {
		EnumDeclarationContext _localctx = new EnumDeclarationContext(Context, State);
		EnterRule(_localctx, 20, RULE_enumDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocComment) {
				{
				State = 157;
				_localctx.doc = Match(DocComment);
				}
			}

			State = 163;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==At) {
				{
				{
				State = 160;
				_localctx._schemaProperty = schemaProperty();
				_localctx._schemaProperties.Add(_localctx._schemaProperty);
				}
				}
				State = 165;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 166;
			Match(Enum);
			State = 167;
			_localctx.name = identifier();
			State = 168;
			Match(LBrace);
			State = 177;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 144256200442118020L) != 0)) {
				{
				State = 169;
				_localctx._enumSymbol = enumSymbol();
				_localctx._enumSymbols.Add(_localctx._enumSymbol);
				State = 174;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 170;
					Match(Comma);
					State = 171;
					_localctx._enumSymbol = enumSymbol();
					_localctx._enumSymbols.Add(_localctx._enumSymbol);
					}
					}
					State = 176;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 179;
			Match(RBrace);
			State = 181;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EqualsOp) {
				{
				State = 180;
				_localctx.defaultSymbol = enumDefault();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumSymbolContext : ParserRuleContext {
		public IToken doc;
		public SchemaPropertyContext _schemaProperty;
		public IList<SchemaPropertyContext> _schemaProperties = new List<SchemaPropertyContext>();
		public IdentifierContext name;
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocComment() { return GetToken(IdlParser.DocComment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext[] schemaProperty() {
			return GetRuleContexts<SchemaPropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext schemaProperty(int i) {
			return GetRuleContext<SchemaPropertyContext>(i);
		}
		public EnumSymbolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumSymbol; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterEnumSymbol(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitEnumSymbol(this);
		}
	}

	[RuleVersion(0)]
	public EnumSymbolContext enumSymbol() {
		EnumSymbolContext _localctx = new EnumSymbolContext(Context, State);
		EnterRule(_localctx, 22, RULE_enumSymbol);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 184;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocComment) {
				{
				State = 183;
				_localctx.doc = Match(DocComment);
				}
			}

			State = 189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==At) {
				{
				{
				State = 186;
				_localctx._schemaProperty = schemaProperty();
				_localctx._schemaProperties.Add(_localctx._schemaProperty);
				}
				}
				State = 191;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 192;
			_localctx.name = identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumDefaultContext : ParserRuleContext {
		public IdentifierContext defaultSymbolName;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equals() { return GetToken(IdlParser.EqualsOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(IdlParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public EnumDefaultContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumDefault; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterEnumDefault(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitEnumDefault(this);
		}
	}

	[RuleVersion(0)]
	public EnumDefaultContext enumDefault() {
		EnumDefaultContext _localctx = new EnumDefaultContext(Context, State);
		EnterRule(_localctx, 24, RULE_enumDefault);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 194;
			Match(EqualsOp);
			State = 195;
			_localctx.defaultSymbolName = identifier();
			State = 196;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RecordDeclarationContext : ParserRuleContext {
		public IToken doc;
		public SchemaPropertyContext _schemaProperty;
		public IList<SchemaPropertyContext> _schemaProperties = new List<SchemaPropertyContext>();
		public IToken recordType;
		public IdentifierContext name;
		public RecordBodyContext body;
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecordBodyContext recordBody() {
			return GetRuleContext<RecordBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Record() { return GetToken(IdlParser.Record, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Error() { return GetToken(IdlParser.Error, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocComment() { return GetToken(IdlParser.DocComment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext[] schemaProperty() {
			return GetRuleContexts<SchemaPropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext schemaProperty(int i) {
			return GetRuleContext<SchemaPropertyContext>(i);
		}
		public RecordDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_recordDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterRecordDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitRecordDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public RecordDeclarationContext recordDeclaration() {
		RecordDeclarationContext _localctx = new RecordDeclarationContext(Context, State);
		EnterRule(_localctx, 26, RULE_recordDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 199;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocComment) {
				{
				State = 198;
				_localctx.doc = Match(DocComment);
				}
			}

			State = 204;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==At) {
				{
				{
				State = 201;
				_localctx._schemaProperty = schemaProperty();
				_localctx._schemaProperties.Add(_localctx._schemaProperty);
				}
				}
				State = 206;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 207;
			_localctx.recordType = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==Error || _la==Record) ) {
				_localctx.recordType = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 208;
			_localctx.name = identifier();
			State = 209;
			_localctx.body = recordBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RecordBodyContext : ParserRuleContext {
		public FieldDeclarationContext _fieldDeclaration;
		public IList<FieldDeclarationContext> _fields = new List<FieldDeclarationContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBrace() { return GetToken(IdlParser.LBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBrace() { return GetToken(IdlParser.RBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FieldDeclarationContext[] fieldDeclaration() {
			return GetRuleContexts<FieldDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FieldDeclarationContext fieldDeclaration(int i) {
			return GetRuleContext<FieldDeclarationContext>(i);
		}
		public RecordBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_recordBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterRecordBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitRecordBody(this);
		}
	}

	[RuleVersion(0)]
	public RecordBodyContext recordBody() {
		RecordBodyContext _localctx = new RecordBodyContext(Context, State);
		EnterRule(_localctx, 28, RULE_recordBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211;
			Match(LBrace);
			State = 215;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 144256200442118020L) != 0)) {
				{
				{
				State = 212;
				_localctx._fieldDeclaration = fieldDeclaration();
				_localctx._fields.Add(_localctx._fieldDeclaration);
				}
				}
				State = 217;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 218;
			Match(RBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldDeclarationContext : ParserRuleContext {
		public IToken doc;
		public FullTypeContext fieldType;
		public VariableDeclarationContext _variableDeclaration;
		public IList<VariableDeclarationContext> _variableDeclarations = new List<VariableDeclarationContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(IdlParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullTypeContext fullType() {
			return GetRuleContext<FullTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclarationContext[] variableDeclaration() {
			return GetRuleContexts<VariableDeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclarationContext variableDeclaration(int i) {
			return GetRuleContext<VariableDeclarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(IdlParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(IdlParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocComment() { return GetToken(IdlParser.DocComment, 0); }
		public FieldDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fieldDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterFieldDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitFieldDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public FieldDeclarationContext fieldDeclaration() {
		FieldDeclarationContext _localctx = new FieldDeclarationContext(Context, State);
		EnterRule(_localctx, 30, RULE_fieldDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 221;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocComment) {
				{
				State = 220;
				_localctx.doc = Match(DocComment);
				}
			}

			State = 223;
			_localctx.fieldType = fullType();
			State = 224;
			_localctx._variableDeclaration = variableDeclaration();
			_localctx._variableDeclarations.Add(_localctx._variableDeclaration);
			State = 229;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 225;
				Match(Comma);
				State = 226;
				_localctx._variableDeclaration = variableDeclaration();
				_localctx._variableDeclarations.Add(_localctx._variableDeclaration);
				}
				}
				State = 231;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 232;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableDeclarationContext : ParserRuleContext {
		public IToken doc;
		public SchemaPropertyContext _schemaProperty;
		public IList<SchemaPropertyContext> _schemaProperties = new List<SchemaPropertyContext>();
		public IdentifierContext fieldName;
		public JsonValueContext defaultValue;
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equals() { return GetToken(IdlParser.EqualsOp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocComment() { return GetToken(IdlParser.DocComment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext[] schemaProperty() {
			return GetRuleContexts<SchemaPropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext schemaProperty(int i) {
			return GetRuleContext<SchemaPropertyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueContext jsonValue() {
			return GetRuleContext<JsonValueContext>(0);
		}
		public VariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitVariableDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public VariableDeclarationContext variableDeclaration() {
		VariableDeclarationContext _localctx = new VariableDeclarationContext(Context, State);
		EnterRule(_localctx, 32, RULE_variableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 235;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocComment) {
				{
				State = 234;
				_localctx.doc = Match(DocComment);
				}
			}

			State = 240;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==At) {
				{
				{
				State = 237;
				_localctx._schemaProperty = schemaProperty();
				_localctx._schemaProperties.Add(_localctx._schemaProperty);
				}
				}
				State = 242;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 243;
			_localctx.fieldName = identifier();
			State = 246;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EqualsOp) {
				{
				State = 244;
				Match(EqualsOp);
				State = 245;
				_localctx.defaultValue = jsonValue();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MessageDeclarationContext : ParserRuleContext {
		public IToken doc;
		public SchemaPropertyContext _schemaProperty;
		public IList<SchemaPropertyContext> _schemaProperties = new List<SchemaPropertyContext>();
		public ResultTypeContext returnType;
		public IdentifierContext name;
		public FormalParameterContext _formalParameter;
		public IList<FormalParameterContext> _formalParameters = new List<FormalParameterContext>();
		public IToken oneway;
		public IdentifierContext _identifier;
		public IList<IdentifierContext> _errors = new List<IdentifierContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LParen() { return GetToken(IdlParser.LParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RParen() { return GetToken(IdlParser.RParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon() { return GetToken(IdlParser.Semicolon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ResultTypeContext resultType() {
			return GetRuleContext<ResultTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Throws() { return GetToken(IdlParser.Throws, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocComment() { return GetToken(IdlParser.DocComment, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext[] schemaProperty() {
			return GetRuleContexts<SchemaPropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext schemaProperty(int i) {
			return GetRuleContext<SchemaPropertyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FormalParameterContext[] formalParameter() {
			return GetRuleContexts<FormalParameterContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FormalParameterContext formalParameter(int i) {
			return GetRuleContext<FormalParameterContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Oneway() { return GetToken(IdlParser.Oneway, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(IdlParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(IdlParser.Comma, i);
		}
		public MessageDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_messageDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterMessageDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitMessageDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public MessageDeclarationContext messageDeclaration() {
		MessageDeclarationContext _localctx = new MessageDeclarationContext(Context, State);
		EnterRule(_localctx, 34, RULE_messageDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 249;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocComment) {
				{
				State = 248;
				_localctx.doc = Match(DocComment);
				}
			}

			State = 254;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==At) {
				{
				{
				State = 251;
				_localctx._schemaProperty = schemaProperty();
				_localctx._schemaProperties.Add(_localctx._schemaProperty);
				}
				}
				State = 256;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 257;
			_localctx.returnType = resultType();
			State = 258;
			_localctx.name = identifier();
			State = 259;
			Match(LParen);
			State = 268;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 144256200442118020L) != 0)) {
				{
				State = 260;
				_localctx._formalParameter = formalParameter();
				_localctx._formalParameters.Add(_localctx._formalParameter);
				State = 265;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 261;
					Match(Comma);
					State = 262;
					_localctx._formalParameter = formalParameter();
					_localctx._formalParameters.Add(_localctx._formalParameter);
					}
					}
					State = 267;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 270;
			Match(RParen);
			State = 281;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Oneway:
				{
				State = 271;
				_localctx.oneway = Match(Oneway);
				}
				break;
			case Throws:
				{
				State = 272;
				Match(Throws);
				State = 273;
				_localctx._identifier = identifier();
				_localctx._errors.Add(_localctx._identifier);
				State = 278;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 274;
					Match(Comma);
					State = 275;
					_localctx._identifier = identifier();
					_localctx._errors.Add(_localctx._identifier);
					}
					}
					State = 280;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case Semicolon:
				break;
			default:
				break;
			}
			State = 283;
			Match(Semicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FormalParameterContext : ParserRuleContext {
		public IToken doc;
		public FullTypeContext parameterType;
		public VariableDeclarationContext parameter;
		[System.Diagnostics.DebuggerNonUserCode] public FullTypeContext fullType() {
			return GetRuleContext<FullTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclarationContext variableDeclaration() {
			return GetRuleContext<VariableDeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocComment() { return GetToken(IdlParser.DocComment, 0); }
		public FormalParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_formalParameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterFormalParameter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitFormalParameter(this);
		}
	}

	[RuleVersion(0)]
	public FormalParameterContext formalParameter() {
		FormalParameterContext _localctx = new FormalParameterContext(Context, State);
		EnterRule(_localctx, 36, RULE_formalParameter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 286;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocComment) {
				{
				State = 285;
				_localctx.doc = Match(DocComment);
				}
			}

			State = 288;
			_localctx.parameterType = fullType();
			State = 289;
			_localctx.parameter = variableDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResultTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Void() { return GetToken(IdlParser.Void, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PlainTypeContext plainType() {
			return GetRuleContext<PlainTypeContext>(0);
		}
		public ResultTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resultType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterResultType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitResultType(this);
		}
	}

	[RuleVersion(0)]
	public ResultTypeContext resultType() {
		ResultTypeContext _localctx = new ResultTypeContext(Context, State);
		EnterRule(_localctx, 38, RULE_resultType);
		try {
			State = 293;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,36,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 291;
				Match(Void);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 292;
				plainType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FullTypeContext : ParserRuleContext {
		public SchemaPropertyContext _schemaProperty;
		public IList<SchemaPropertyContext> _schemaProperties = new List<SchemaPropertyContext>();
		[System.Diagnostics.DebuggerNonUserCode] public PlainTypeContext plainType() {
			return GetRuleContext<PlainTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext[] schemaProperty() {
			return GetRuleContexts<SchemaPropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SchemaPropertyContext schemaProperty(int i) {
			return GetRuleContext<SchemaPropertyContext>(i);
		}
		public FullTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fullType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterFullType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitFullType(this);
		}
	}

	[RuleVersion(0)]
	public FullTypeContext fullType() {
		FullTypeContext _localctx = new FullTypeContext(Context, State);
		EnterRule(_localctx, 40, RULE_fullType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 298;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==At) {
				{
				{
				State = 295;
				_localctx._schemaProperty = schemaProperty();
				_localctx._schemaProperties.Add(_localctx._schemaProperty);
				}
				}
				State = 300;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 301;
			plainType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PlainTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrayTypeContext arrayType() {
			return GetRuleContext<ArrayTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MapTypeContext mapType() {
			return GetRuleContext<MapTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnionTypeContext unionType() {
			return GetRuleContext<UnionTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullableTypeContext nullableType() {
			return GetRuleContext<NullableTypeContext>(0);
		}
		public PlainTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plainType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterPlainType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitPlainType(this);
		}
	}

	[RuleVersion(0)]
	public PlainTypeContext plainType() {
		PlainTypeContext _localctx = new PlainTypeContext(Context, State);
		EnterRule(_localctx, 42, RULE_plainType);
		try {
			State = 307;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,38,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 303;
				arrayType();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 304;
				mapType();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 305;
				unionType();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 306;
				nullableType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullableTypeContext : ParserRuleContext {
		public IdentifierContext referenceName;
		public IToken optional;
		[System.Diagnostics.DebuggerNonUserCode] public PrimitiveTypeContext primitiveType() {
			return GetRuleContext<PrimitiveTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(IdlParser.QuestionMark, 0); }
		public NullableTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullableType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterNullableType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitNullableType(this);
		}
	}

	[RuleVersion(0)]
	public NullableTypeContext nullableType() {
		NullableTypeContext _localctx = new NullableTypeContext(Context, State);
		EnterRule(_localctx, 44, RULE_nullableType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 311;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				{
				State = 309;
				primitiveType();
				}
				break;
			case 2:
				{
				State = 310;
				_localctx.referenceName = identifier();
				}
				break;
			}
			State = 314;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QuestionMark) {
				{
				State = 313;
				_localctx.optional = Match(QuestionMark);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimitiveTypeContext : ParserRuleContext {
		public IToken typeName;
		public IToken precision;
		public IToken scale;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Boolean() { return GetToken(IdlParser.Boolean, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Int() { return GetToken(IdlParser.Int, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Long() { return GetToken(IdlParser.Long, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Float() { return GetToken(IdlParser.Float, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Double() { return GetToken(IdlParser.Double, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Bytes() { return GetToken(IdlParser.Bytes, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(IdlParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Null() { return GetToken(IdlParser.Null, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Date() { return GetToken(IdlParser.Date, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Time() { return GetToken(IdlParser.Time, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Timestamp() { return GetToken(IdlParser.Timestamp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LocalTimestamp() { return GetToken(IdlParser.LocalTimestamp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UUID() { return GetToken(IdlParser.UUID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LParen() { return GetToken(IdlParser.LParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RParen() { return GetToken(IdlParser.RParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Decimal() { return GetToken(IdlParser.Decimal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] IntegerLiteral() { return GetTokens(IdlParser.IntegerLiteral); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntegerLiteral(int i) {
			return GetToken(IdlParser.IntegerLiteral, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(IdlParser.Comma, 0); }
		public PrimitiveTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primitiveType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterPrimitiveType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitPrimitiveType(this);
		}
	}

	[RuleVersion(0)]
	public PrimitiveTypeContext primitiveType() {
		PrimitiveTypeContext _localctx = new PrimitiveTypeContext(Context, State);
		EnterRule(_localctx, 46, RULE_primitiveType);
		int _la;
		try {
			State = 325;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Boolean:
			case Int:
			case Long:
			case Float:
			case Double:
			case String:
			case Bytes:
			case Null:
			case Date:
			case Time:
			case Timestamp:
			case LocalTimestamp:
			case UUID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 316;
				_localctx.typeName = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 33419689984L) != 0)) ) {
					_localctx.typeName = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case Decimal:
				EnterOuterAlt(_localctx, 2);
				{
				State = 317;
				_localctx.typeName = Match(Decimal);
				State = 318;
				Match(LParen);
				State = 319;
				_localctx.precision = Match(IntegerLiteral);
				State = 322;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 320;
					Match(Comma);
					State = 321;
					_localctx.scale = Match(IntegerLiteral);
					}
				}

				State = 324;
				Match(RParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayTypeContext : ParserRuleContext {
		public FullTypeContext elementType;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Array() { return GetToken(IdlParser.Array, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT() { return GetToken(IdlParser.LT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT() { return GetToken(IdlParser.GT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullTypeContext fullType() {
			return GetRuleContext<FullTypeContext>(0);
		}
		public ArrayTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterArrayType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitArrayType(this);
		}
	}

	[RuleVersion(0)]
	public ArrayTypeContext arrayType() {
		ArrayTypeContext _localctx = new ArrayTypeContext(Context, State);
		EnterRule(_localctx, 48, RULE_arrayType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 327;
			Match(Array);
			State = 328;
			Match(LT);
			State = 329;
			_localctx.elementType = fullType();
			State = 330;
			Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MapTypeContext : ParserRuleContext {
		public FullTypeContext valueType;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Map() { return GetToken(IdlParser.Map, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT() { return GetToken(IdlParser.LT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT() { return GetToken(IdlParser.GT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullTypeContext fullType() {
			return GetRuleContext<FullTypeContext>(0);
		}
		public MapTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mapType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterMapType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitMapType(this);
		}
	}

	[RuleVersion(0)]
	public MapTypeContext mapType() {
		MapTypeContext _localctx = new MapTypeContext(Context, State);
		EnterRule(_localctx, 50, RULE_mapType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 332;
			Match(Map);
			State = 333;
			Match(LT);
			State = 334;
			_localctx.valueType = fullType();
			State = 335;
			Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnionTypeContext : ParserRuleContext {
		public FullTypeContext _fullType;
		public IList<FullTypeContext> _types = new List<FullTypeContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Union() { return GetToken(IdlParser.Union, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBrace() { return GetToken(IdlParser.LBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBrace() { return GetToken(IdlParser.RBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FullTypeContext[] fullType() {
			return GetRuleContexts<FullTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FullTypeContext fullType(int i) {
			return GetRuleContext<FullTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(IdlParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(IdlParser.Comma, i);
		}
		public UnionTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unionType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterUnionType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitUnionType(this);
		}
	}

	[RuleVersion(0)]
	public UnionTypeContext unionType() {
		UnionTypeContext _localctx = new UnionTypeContext(Context, State);
		EnterRule(_localctx, 52, RULE_unionType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 337;
			Match(Union);
			State = 338;
			Match(LBrace);
			State = 339;
			_localctx._fullType = fullType();
			_localctx._types.Add(_localctx._fullType);
			State = 344;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 340;
				Match(Comma);
				State = 341;
				_localctx._fullType = fullType();
				_localctx._types.Add(_localctx._fullType);
				}
				}
				State = 346;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 347;
			Match(RBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public JsonObjectContext jsonObject() {
			return GetRuleContext<JsonObjectContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonArrayContext jsonArray() {
			return GetRuleContext<JsonArrayContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonLiteralContext jsonLiteral() {
			return GetRuleContext<JsonLiteralContext>(0);
		}
		public JsonValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterJsonValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitJsonValue(this);
		}
	}

	[RuleVersion(0)]
	public JsonValueContext jsonValue() {
		JsonValueContext _localctx = new JsonValueContext(Context, State);
		EnterRule(_localctx, 54, RULE_jsonValue);
		try {
			State = 352;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LBrace:
				EnterOuterAlt(_localctx, 1);
				{
				State = 349;
				jsonObject();
				}
				break;
			case LBracket:
				EnterOuterAlt(_localctx, 2);
				{
				State = 350;
				jsonArray();
				}
				break;
			case Null:
			case BTrue:
			case BFalse:
			case StringLiteral:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 351;
				jsonLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonLiteralContext : ParserRuleContext {
		public IToken literal;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(IdlParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntegerLiteral() { return GetToken(IdlParser.IntegerLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FloatingPointLiteral() { return GetToken(IdlParser.FloatingPointLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BTrue() { return GetToken(IdlParser.BTrue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BFalse() { return GetToken(IdlParser.BFalse, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Null() { return GetToken(IdlParser.Null, 0); }
		public JsonLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterJsonLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitJsonLiteral(this);
		}
	}

	[RuleVersion(0)]
	public JsonLiteralContext jsonLiteral() {
		JsonLiteralContext _localctx = new JsonLiteralContext(Context, State);
		EnterRule(_localctx, 56, RULE_jsonLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 354;
			_localctx.literal = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 126100790036135936L) != 0)) ) {
				_localctx.literal = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonObjectContext : ParserRuleContext {
		public JsonPairContext _jsonPair;
		public IList<JsonPairContext> _jsonPairs = new List<JsonPairContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBrace() { return GetToken(IdlParser.LBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBrace() { return GetToken(IdlParser.RBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonPairContext[] jsonPair() {
			return GetRuleContexts<JsonPairContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonPairContext jsonPair(int i) {
			return GetRuleContext<JsonPairContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(IdlParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(IdlParser.Comma, i);
		}
		public JsonObjectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonObject; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterJsonObject(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitJsonObject(this);
		}
	}

	[RuleVersion(0)]
	public JsonObjectContext jsonObject() {
		JsonObjectContext _localctx = new JsonObjectContext(Context, State);
		EnterRule(_localctx, 58, RULE_jsonObject);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 356;
			Match(LBrace);
			State = 365;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==StringLiteral) {
				{
				State = 357;
				_localctx._jsonPair = jsonPair();
				_localctx._jsonPairs.Add(_localctx._jsonPair);
				State = 362;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 358;
					Match(Comma);
					State = 359;
					_localctx._jsonPair = jsonPair();
					_localctx._jsonPairs.Add(_localctx._jsonPair);
					}
					}
					State = 364;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 367;
			Match(RBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonPairContext : ParserRuleContext {
		public IToken name;
		public JsonValueContext value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(IdlParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(IdlParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueContext jsonValue() {
			return GetRuleContext<JsonValueContext>(0);
		}
		public JsonPairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonPair; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterJsonPair(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitJsonPair(this);
		}
	}

	[RuleVersion(0)]
	public JsonPairContext jsonPair() {
		JsonPairContext _localctx = new JsonPairContext(Context, State);
		EnterRule(_localctx, 60, RULE_jsonPair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 369;
			_localctx.name = Match(StringLiteral);
			State = 370;
			Match(Colon);
			State = 371;
			_localctx.value = jsonValue();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonArrayContext : ParserRuleContext {
		public JsonValueContext _jsonValue;
		public IList<JsonValueContext> _jsonValues = new List<JsonValueContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBracket() { return GetToken(IdlParser.LBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBracket() { return GetToken(IdlParser.RBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueContext[] jsonValue() {
			return GetRuleContexts<JsonValueContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public JsonValueContext jsonValue(int i) {
			return GetRuleContext<JsonValueContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(IdlParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(IdlParser.Comma, i);
		}
		public JsonArrayContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonArray; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.EnterJsonArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IIdlListener typedListener = listener as IIdlListener;
			if (typedListener != null) typedListener.ExitJsonArray(this);
		}
	}

	[RuleVersion(0)]
	public JsonArrayContext jsonArray() {
		JsonArrayContext _localctx = new JsonArrayContext(Context, State);
		EnterRule(_localctx, 62, RULE_jsonArray);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 373;
			Match(LBracket);
			State = 382;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 126106287594274816L) != 0)) {
				{
				State = 374;
				_localctx._jsonValue = jsonValue();
				_localctx._jsonValues.Add(_localctx._jsonValue);
				State = 379;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 375;
					Match(Comma);
					State = 376;
					_localctx._jsonValue = jsonValue();
					_localctx._jsonValues.Add(_localctx._jsonValue);
					}
					}
					State = 381;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 384;
			Match(RBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,57,387,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,1,0,1,0,3,0,67,8,0,1,0,3,0,70,8,0,1,0,1,
		0,5,0,74,8,0,10,0,12,0,77,9,0,3,0,79,8,0,1,0,1,0,5,0,83,8,0,10,0,12,0,
		86,9,0,3,0,88,8,0,1,0,1,0,1,1,3,1,93,8,1,1,1,5,1,96,8,1,10,1,12,1,99,9,
		1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,5,2,109,8,2,10,2,12,2,112,9,2,1,2,1,
		2,1,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,7,
		1,7,1,7,1,7,1,7,1,8,1,8,1,8,3,8,140,8,8,1,9,3,9,143,8,9,1,9,5,9,146,8,
		9,10,9,12,9,149,9,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,10,3,10,159,8,10,1,10,
		5,10,162,8,10,10,10,12,10,165,9,10,1,10,1,10,1,10,1,10,1,10,1,10,5,10,
		173,8,10,10,10,12,10,176,9,10,3,10,178,8,10,1,10,1,10,3,10,182,8,10,1,
		11,3,11,185,8,11,1,11,5,11,188,8,11,10,11,12,11,191,9,11,1,11,1,11,1,12,
		1,12,1,12,1,12,1,13,3,13,200,8,13,1,13,5,13,203,8,13,10,13,12,13,206,9,
		13,1,13,1,13,1,13,1,13,1,14,1,14,5,14,214,8,14,10,14,12,14,217,9,14,1,
		14,1,14,1,15,3,15,222,8,15,1,15,1,15,1,15,1,15,5,15,228,8,15,10,15,12,
		15,231,9,15,1,15,1,15,1,16,3,16,236,8,16,1,16,5,16,239,8,16,10,16,12,16,
		242,9,16,1,16,1,16,1,16,3,16,247,8,16,1,17,3,17,250,8,17,1,17,5,17,253,
		8,17,10,17,12,17,256,9,17,1,17,1,17,1,17,1,17,1,17,1,17,5,17,264,8,17,
		10,17,12,17,267,9,17,3,17,269,8,17,1,17,1,17,1,17,1,17,1,17,1,17,5,17,
		277,8,17,10,17,12,17,280,9,17,3,17,282,8,17,1,17,1,17,1,18,3,18,287,8,
		18,1,18,1,18,1,18,1,19,1,19,3,19,294,8,19,1,20,5,20,297,8,20,10,20,12,
		20,300,9,20,1,20,1,20,1,21,1,21,1,21,1,21,3,21,308,8,21,1,22,1,22,3,22,
		312,8,22,1,22,3,22,315,8,22,1,23,1,23,1,23,1,23,1,23,1,23,3,23,323,8,23,
		1,23,3,23,326,8,23,1,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,25,1,
		26,1,26,1,26,1,26,1,26,5,26,343,8,26,10,26,12,26,346,9,26,1,26,1,26,1,
		27,1,27,1,27,3,27,353,8,27,1,28,1,28,1,29,1,29,1,29,1,29,5,29,361,8,29,
		10,29,12,29,364,9,29,3,29,366,8,29,1,29,1,29,1,30,1,30,1,30,1,30,1,31,
		1,31,1,31,1,31,5,31,378,8,31,10,31,12,31,381,9,31,3,31,383,8,31,1,31,1,
		31,1,31,1,84,0,32,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,
		38,40,42,44,46,48,50,52,54,56,58,60,62,0,5,2,0,7,37,57,57,2,0,7,7,10,11,
		1,0,14,15,2,0,19,26,30,34,2,0,26,28,54,56,409,0,78,1,0,0,0,2,92,1,0,0,
		0,4,104,1,0,0,0,6,115,1,0,0,0,8,119,1,0,0,0,10,123,1,0,0,0,12,125,1,0,
		0,0,14,131,1,0,0,0,16,139,1,0,0,0,18,142,1,0,0,0,20,158,1,0,0,0,22,184,
		1,0,0,0,24,194,1,0,0,0,26,199,1,0,0,0,28,211,1,0,0,0,30,221,1,0,0,0,32,
		235,1,0,0,0,34,249,1,0,0,0,36,286,1,0,0,0,38,293,1,0,0,0,40,298,1,0,0,
		0,42,307,1,0,0,0,44,311,1,0,0,0,46,325,1,0,0,0,48,327,1,0,0,0,50,332,1,
		0,0,0,52,337,1,0,0,0,54,352,1,0,0,0,56,354,1,0,0,0,58,356,1,0,0,0,60,369,
		1,0,0,0,62,373,1,0,0,0,64,79,3,2,1,0,65,67,3,6,3,0,66,65,1,0,0,0,66,67,
		1,0,0,0,67,69,1,0,0,0,68,70,3,8,4,0,69,68,1,0,0,0,69,70,1,0,0,0,70,75,
		1,0,0,0,71,74,3,14,7,0,72,74,3,16,8,0,73,71,1,0,0,0,73,72,1,0,0,0,74,77,
		1,0,0,0,75,73,1,0,0,0,75,76,1,0,0,0,76,79,1,0,0,0,77,75,1,0,0,0,78,64,
		1,0,0,0,78,66,1,0,0,0,79,87,1,0,0,0,80,84,5,1,0,0,81,83,9,0,0,0,82,81,
		1,0,0,0,83,86,1,0,0,0,84,85,1,0,0,0,84,82,1,0,0,0,85,88,1,0,0,0,86,84,
		1,0,0,0,87,80,1,0,0,0,87,88,1,0,0,0,88,89,1,0,0,0,89,90,5,0,0,1,90,1,1,
		0,0,0,91,93,5,2,0,0,92,91,1,0,0,0,92,93,1,0,0,0,93,97,1,0,0,0,94,96,3,
		12,6,0,95,94,1,0,0,0,96,99,1,0,0,0,97,95,1,0,0,0,97,98,1,0,0,0,98,100,
		1,0,0,0,99,97,1,0,0,0,100,101,5,7,0,0,101,102,3,10,5,0,102,103,3,4,2,0,
		103,3,1,0,0,0,104,110,5,40,0,0,105,109,3,14,7,0,106,109,3,16,8,0,107,109,
		3,34,17,0,108,105,1,0,0,0,108,106,1,0,0,0,108,107,1,0,0,0,109,112,1,0,
		0,0,110,108,1,0,0,0,110,111,1,0,0,0,111,113,1,0,0,0,112,110,1,0,0,0,113,
		114,5,41,0,0,114,5,1,0,0,0,115,116,5,8,0,0,116,117,3,10,5,0,117,118,5,
		45,0,0,118,7,1,0,0,0,119,120,5,11,0,0,120,121,3,40,20,0,121,122,5,45,0,
		0,122,9,1,0,0,0,123,124,7,0,0,0,124,11,1,0,0,0,125,126,5,47,0,0,126,127,
		3,10,5,0,127,128,5,38,0,0,128,129,3,54,27,0,129,130,5,39,0,0,130,13,1,
		0,0,0,131,132,5,9,0,0,132,133,7,1,0,0,133,134,5,54,0,0,134,135,5,45,0,
		0,135,15,1,0,0,0,136,140,3,18,9,0,137,140,3,20,10,0,138,140,3,26,13,0,
		139,136,1,0,0,0,139,137,1,0,0,0,139,138,1,0,0,0,140,17,1,0,0,0,141,143,
		5,2,0,0,142,141,1,0,0,0,142,143,1,0,0,0,143,147,1,0,0,0,144,146,3,12,6,
		0,145,144,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,148,1,0,0,0,148,
		150,1,0,0,0,149,147,1,0,0,0,150,151,5,13,0,0,151,152,3,10,5,0,152,153,
		5,38,0,0,153,154,5,55,0,0,154,155,5,39,0,0,155,156,5,45,0,0,156,19,1,0,
		0,0,157,159,5,2,0,0,158,157,1,0,0,0,158,159,1,0,0,0,159,163,1,0,0,0,160,
		162,3,12,6,0,161,160,1,0,0,0,162,165,1,0,0,0,163,161,1,0,0,0,163,164,1,
		0,0,0,164,166,1,0,0,0,165,163,1,0,0,0,166,167,5,12,0,0,167,168,3,10,5,
		0,168,177,5,40,0,0,169,174,3,22,11,0,170,171,5,46,0,0,171,173,3,22,11,
		0,172,170,1,0,0,0,173,176,1,0,0,0,174,172,1,0,0,0,174,175,1,0,0,0,175,
		178,1,0,0,0,176,174,1,0,0,0,177,169,1,0,0,0,177,178,1,0,0,0,178,179,1,
		0,0,0,179,181,5,41,0,0,180,182,3,24,12,0,181,180,1,0,0,0,181,182,1,0,0,
		0,182,21,1,0,0,0,183,185,5,2,0,0,184,183,1,0,0,0,184,185,1,0,0,0,185,189,
		1,0,0,0,186,188,3,12,6,0,187,186,1,0,0,0,188,191,1,0,0,0,189,187,1,0,0,
		0,189,190,1,0,0,0,190,192,1,0,0,0,191,189,1,0,0,0,192,193,3,10,5,0,193,
		23,1,0,0,0,194,195,5,48,0,0,195,196,3,10,5,0,196,197,5,45,0,0,197,25,1,
		0,0,0,198,200,5,2,0,0,199,198,1,0,0,0,199,200,1,0,0,0,200,204,1,0,0,0,
		201,203,3,12,6,0,202,201,1,0,0,0,203,206,1,0,0,0,204,202,1,0,0,0,204,205,
		1,0,0,0,205,207,1,0,0,0,206,204,1,0,0,0,207,208,7,2,0,0,208,209,3,10,5,
		0,209,210,3,28,14,0,210,27,1,0,0,0,211,215,5,40,0,0,212,214,3,30,15,0,
		213,212,1,0,0,0,214,217,1,0,0,0,215,213,1,0,0,0,215,216,1,0,0,0,216,218,
		1,0,0,0,217,215,1,0,0,0,218,219,5,41,0,0,219,29,1,0,0,0,220,222,5,2,0,
		0,221,220,1,0,0,0,221,222,1,0,0,0,222,223,1,0,0,0,223,224,3,40,20,0,224,
		229,3,32,16,0,225,226,5,46,0,0,226,228,3,32,16,0,227,225,1,0,0,0,228,231,
		1,0,0,0,229,227,1,0,0,0,229,230,1,0,0,0,230,232,1,0,0,0,231,229,1,0,0,
		0,232,233,5,45,0,0,233,31,1,0,0,0,234,236,5,2,0,0,235,234,1,0,0,0,235,
		236,1,0,0,0,236,240,1,0,0,0,237,239,3,12,6,0,238,237,1,0,0,0,239,242,1,
		0,0,0,240,238,1,0,0,0,240,241,1,0,0,0,241,243,1,0,0,0,242,240,1,0,0,0,
		243,246,3,10,5,0,244,245,5,48,0,0,245,247,3,54,27,0,246,244,1,0,0,0,246,
		247,1,0,0,0,247,33,1,0,0,0,248,250,5,2,0,0,249,248,1,0,0,0,249,250,1,0,
		0,0,250,254,1,0,0,0,251,253,3,12,6,0,252,251,1,0,0,0,253,256,1,0,0,0,254,
		252,1,0,0,0,254,255,1,0,0,0,255,257,1,0,0,0,256,254,1,0,0,0,257,258,3,
		38,19,0,258,259,3,10,5,0,259,268,5,38,0,0,260,265,3,36,18,0,261,262,5,
		46,0,0,262,264,3,36,18,0,263,261,1,0,0,0,264,267,1,0,0,0,265,263,1,0,0,
		0,265,266,1,0,0,0,266,269,1,0,0,0,267,265,1,0,0,0,268,260,1,0,0,0,268,
		269,1,0,0,0,269,270,1,0,0,0,270,281,5,39,0,0,271,282,5,36,0,0,272,273,
		5,37,0,0,273,278,3,10,5,0,274,275,5,46,0,0,275,277,3,10,5,0,276,274,1,
		0,0,0,277,280,1,0,0,0,278,276,1,0,0,0,278,279,1,0,0,0,279,282,1,0,0,0,
		280,278,1,0,0,0,281,271,1,0,0,0,281,272,1,0,0,0,281,282,1,0,0,0,282,283,
		1,0,0,0,283,284,5,45,0,0,284,35,1,0,0,0,285,287,5,2,0,0,286,285,1,0,0,
		0,286,287,1,0,0,0,287,288,1,0,0,0,288,289,3,40,20,0,289,290,3,32,16,0,
		290,37,1,0,0,0,291,294,5,35,0,0,292,294,3,42,21,0,293,291,1,0,0,0,293,
		292,1,0,0,0,294,39,1,0,0,0,295,297,3,12,6,0,296,295,1,0,0,0,297,300,1,
		0,0,0,298,296,1,0,0,0,298,299,1,0,0,0,299,301,1,0,0,0,300,298,1,0,0,0,
		301,302,3,42,21,0,302,41,1,0,0,0,303,308,3,48,24,0,304,308,3,50,25,0,305,
		308,3,52,26,0,306,308,3,44,22,0,307,303,1,0,0,0,307,304,1,0,0,0,307,305,
		1,0,0,0,307,306,1,0,0,0,308,43,1,0,0,0,309,312,3,46,23,0,310,312,3,10,
		5,0,311,309,1,0,0,0,311,310,1,0,0,0,312,314,1,0,0,0,313,315,5,51,0,0,314,
		313,1,0,0,0,314,315,1,0,0,0,315,45,1,0,0,0,316,326,7,3,0,0,317,318,5,29,
		0,0,318,319,5,38,0,0,319,322,5,55,0,0,320,321,5,46,0,0,321,323,5,55,0,
		0,322,320,1,0,0,0,322,323,1,0,0,0,323,324,1,0,0,0,324,326,5,39,0,0,325,
		316,1,0,0,0,325,317,1,0,0,0,326,47,1,0,0,0,327,328,5,16,0,0,328,329,5,
		52,0,0,329,330,3,40,20,0,330,331,5,53,0,0,331,49,1,0,0,0,332,333,5,17,
		0,0,333,334,5,52,0,0,334,335,3,40,20,0,335,336,5,53,0,0,336,51,1,0,0,0,
		337,338,5,18,0,0,338,339,5,40,0,0,339,344,3,40,20,0,340,341,5,46,0,0,341,
		343,3,40,20,0,342,340,1,0,0,0,343,346,1,0,0,0,344,342,1,0,0,0,344,345,
		1,0,0,0,345,347,1,0,0,0,346,344,1,0,0,0,347,348,5,41,0,0,348,53,1,0,0,
		0,349,353,3,58,29,0,350,353,3,62,31,0,351,353,3,56,28,0,352,349,1,0,0,
		0,352,350,1,0,0,0,352,351,1,0,0,0,353,55,1,0,0,0,354,355,7,4,0,0,355,57,
		1,0,0,0,356,365,5,40,0,0,357,362,3,60,30,0,358,359,5,46,0,0,359,361,3,
		60,30,0,360,358,1,0,0,0,361,364,1,0,0,0,362,360,1,0,0,0,362,363,1,0,0,
		0,363,366,1,0,0,0,364,362,1,0,0,0,365,357,1,0,0,0,365,366,1,0,0,0,366,
		367,1,0,0,0,367,368,5,41,0,0,368,59,1,0,0,0,369,370,5,54,0,0,370,371,5,
		44,0,0,371,372,3,54,27,0,372,61,1,0,0,0,373,382,5,42,0,0,374,379,3,54,
		27,0,375,376,5,46,0,0,376,378,3,54,27,0,377,375,1,0,0,0,378,381,1,0,0,
		0,379,377,1,0,0,0,379,380,1,0,0,0,380,383,1,0,0,0,381,379,1,0,0,0,382,
		374,1,0,0,0,382,383,1,0,0,0,383,384,1,0,0,0,384,385,5,43,0,0,385,63,1,
		0,0,0,49,66,69,73,75,78,84,87,92,97,108,110,139,142,147,158,163,174,177,
		181,184,189,199,204,215,221,229,235,240,246,249,254,265,268,278,281,286,
		293,298,307,311,314,322,325,344,352,362,365,379,382
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
